import { ResolvedConfig } from "../config";
import { Location, Source } from "../context";
import { HtmlElement } from "../dom";
import { EventCallback, EventHandler, ListenEventMap, TriggerEventMap } from "../event";
import { Token, TokenStream, TokenType } from "../lexer";
/**
 * Parse HTML document into a DOM tree.
 */
export declare class Parser {
    private readonly event;
    private readonly metaTable;
    private dom;
    /**
     * Create a new parser instance.
     *
     * @param config - Configuration
     */
    constructor(config: ResolvedConfig);
    /**
     * Parse HTML markup.
     *
     * @param source - HTML markup.
     * @returns DOM tree representing the HTML markup.
     */
    parseHtml(source: string | Source): HtmlElement;
    /**
     * Detect optional end tag.
     *
     * Some tags have optional end tags (e.g. <ul><li>foo<li>bar</ul> is
     * valid). The parser handles this by checking if the element on top of the
     * stack when is allowed to omit.
     */
    private closeOptional;
    protected consumeTag(source: Source, startToken: Token, tokenStream: TokenStream): void;
    protected closeElement(source: Source, node: HtmlElement | null, active: HtmlElement, location: Location): void;
    private processElement;
    /**
     * Discard tokens until the end tag for the foreign element is found.
     */
    protected discardForeignBody(source: Source, foreignTagName: string, tokenStream: TokenStream, errorLocation: Location): void;
    protected consumeAttribute(source: Source, node: HtmlElement, token: Token, next?: Token): void;
    /**
     * Takes attribute key token an returns location.
     */
    private getAttributeKeyLocation;
    /**
     * Take attribute value token and return a new location referring to only the
     * value.
     *
     * foo="bar"    foo='bar'    foo=bar    foo      foo=""
     *      ^^^          ^^^         ^^^    (null)   (null)
     */
    private getAttributeValueLocation;
    /**
     * Take attribute key and value token an returns a new location referring to
     * an aggregate location covering key, quotes if present and value.
     */
    private getAttributeLocation;
    protected consumeDirective(token: Token): void;
    /**
     * Consumes comment token.
     *
     * Tries to find IE conditional comments and emits conditional token if found.
     */
    protected consumeComment(token: Token): void;
    /**
     * Consumes doctype tokens. Emits doctype event.
     */
    protected consumeDoctype(startToken: Token, tokenStream: TokenStream): void;
    /**
     * Return a list of tokens found until the expected token was found.
     *
     * @param errorLocation - What location to use if an error occurs
     */
    protected consumeUntil(tokenStream: TokenStream, search: TokenType, errorLocation: Location): IterableIterator<Token>;
    private next;
    /**
     * Listen on events.
     *
     * @param event - Event name.
     * @param listener - Event callback.
     * @returns A function to unregister the listener.
     */
    on<K extends keyof ListenEventMap>(event: K, listener: (event: string, data: ListenEventMap[K]) => void): () => void;
    on(event: string, listener: EventCallback): () => void;
    /**
     * Listen on single event. The listener is automatically unregistered once the
     * event has been received.
     *
     * @param event - Event name.
     * @param listener - Event callback.
     * @returns A function to unregister the listener.
     */
    once<K extends keyof ListenEventMap>(event: K, listener: (event: string, data: ListenEventMap[K]) => void): () => void;
    once(event: string, listener: EventCallback): () => void;
    /**
     * Defer execution. Will call function sometime later.
     *
     * @param cb - Callback to execute later.
     */
    defer(cb: () => void): void;
    /**
     * Trigger event.
     *
     * @param event - Event name
     * @param data - Event data
     */
    trigger<K extends keyof TriggerEventMap>(event: K, data: TriggerEventMap[K]): void;
    /**
     * @internal
     */
    getEventHandler(): EventHandler;
    /**
     * Appends a text node to the current element on the stack.
     */
    private appendText;
    /**
     * Trigger close events for any still open elements.
     */
    private closeTree;
}
