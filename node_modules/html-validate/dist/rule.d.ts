import { SchemaObject } from "ajv";
import { ConfigData } from "./config";
import { Location } from "./context";
import { DOMNode } from "./dom";
import { ListenEventMap } from "./event";
import { Parser } from "./parser";
import { Reporter } from "./reporter";
import { MetaTable, MetaLookupableProperty } from "./meta";
export { SchemaObject } from "ajv";
export interface RuleDocumentation {
    description: string;
    url?: string;
}
export interface RuleConstructor<T, U> {
    new (options?: any): Rule<T, U>;
    schema(): SchemaObject | null | undefined;
}
export interface IncludeExcludeOptions {
    include: string[] | null;
    exclude: string[] | null;
}
export declare abstract class Rule<ContextType = void, OptionsType = void> {
    private reporter;
    private parser;
    private meta;
    private enabled;
    private severity;
    private event;
    /**
     * Rule name. Defaults to filename without extension but can be overwritten by
     * subclasses.
     */
    name: string;
    /**
     * Rule options.
     */
    readonly options: OptionsType;
    constructor(options: OptionsType);
    getSeverity(): number;
    setServerity(severity: number): void;
    setEnabled(enabled: boolean): void;
    /**
     * Returns `true` if rule is deprecated.
     *
     * Overridden by subclasses.
     */
    get deprecated(): boolean;
    /**
     * Test if rule is enabled.
     *
     * To be considered enabled the enabled flag must be true and the severity at
     * least warning.
     */
    isEnabled(): boolean;
    /**
     * Check if keyword is being ignored by the current rule configuration.
     *
     * This method requires the [[RuleOption]] type to include two properties:
     *
     * - include: string[] | null
     * - exclude: string[] | null
     *
     * This methods checks if the given keyword is included by "include" but not
     * excluded by "exclude". If any property is unset it is skipped by the
     * condition. Usually the user would use either one but not both but there is
     * no limitation to use both but the keyword must satisfy both conditions. If
     * either condition fails `true` is returned.
     *
     * For instance, given `{ include: ["foo"] }` the keyword `"foo"` would match
     * but not `"bar"`.
     *
     * Similarly, given `{ exclude: ["foo"] }` the keyword `"bar"` would match but
     * not `"foo"`.
     *
     * @param keyword - Keyword to match against `include` and `exclude` options.
     * @returns `true` if keyword is not present in `include` or is present in
     * `exclude`.
     */
    isKeywordIgnored<T extends IncludeExcludeOptions>(this: {
        options: T;
    }, keyword: string): boolean;
    /**
     * Find all tags which has enabled given property.
     */
    getTagsWithProperty(propName: MetaLookupableProperty): string[];
    /**
     * Find tag matching tagName or inheriting from it.
     */
    getTagsDerivedFrom(tagName: string): string[];
    /**
     * JSON schema for rule options.
     *
     * Rules should override this to return an object with JSON schema to validate
     * rule options. If `null` or `undefined` is returned no validation is
     * performed.
     */
    static schema(): SchemaObject | null | undefined;
    /**
     * Report a new error.
     *
     * Rule must be enabled both globally and on the specific node for this to
     * have any effect.
     */
    report(node: DOMNode | null, message: string, location?: Location | null, context?: ContextType): void;
    private findLocation;
    /**
     * Listen for events.
     *
     * Adding listeners can be done even if the rule is disabled but for the
     * events to be delivered the rule must be enabled.
     *
     * If the optional filter callback is used it must be a function taking an
     * event of the same type as the listener. The filter is called before the
     * listener and if the filter returns false the event is discarded.
     *
     * @param event - Event name
     * @param filter - Optional filter function. Callback is only called if filter functions return true.
     * @param callback - Callback to handle event.
     * @returns A function to unregister the listener
     */
    on<K extends keyof ListenEventMap>(event: K, callback: (event: ListenEventMap[K]) => void): () => void;
    on<K extends keyof ListenEventMap>(event: K, filter: (event: ListenEventMap[K]) => boolean, callback: (event: ListenEventMap[K]) => void): () => void;
    /**
     * Called by [[Engine]] when initializing the rule.
     *
     * Do not override this, use the `setup` callback instead.
     *
     * @internal
     */
    init(parser: Parser, reporter: Reporter, severity: number, meta: MetaTable): void;
    /**
     * Validate rule options against schema. Throws error if object does not validate.
     *
     * For rules without schema this function does nothing.
     *
     * @throws {@link SchemaValidationError}
     * Thrown when provided options does not validate against rule schema.
     *
     * @param cls - Rule class (constructor)
     * @param ruleId - Rule identifier
     * @param jsonPath - JSON path from which [[options]] can be found in [[config]]
     * @param options - User configured options to be validated
     * @param filename - Filename from which options originated
     * @param config - Configuration from which options originated
     *
     * @internal
     */
    static validateOptions(cls: RuleConstructor<unknown, unknown> | undefined, ruleId: string, jsonPath: string, options: unknown, filename: string | null, config: ConfigData): void;
    /**
     * Rule setup callback.
     *
     * Override this to provide rule setup code.
     */
    abstract setup(): void;
    /**
     * Rule documentation callback.
     *
     * Called when requesting additional documentation for a rule. Some rules
     * provide additional context to provide context-aware suggestions.
     *
     * @param context - Error context given by a reported error.
     * @returns Rule documentation and url with additional details or `null` if no
     * additional documentation is available.
     */
    documentation(context?: ContextType): RuleDocumentation | null;
}
export declare function ruleDocumentationUrl(filename: string): string;
