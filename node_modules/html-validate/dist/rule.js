"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ruleDocumentationUrl = exports.Rule = void 0;
const path_1 = __importDefault(require("path"));
const ajv_1 = __importDefault(require("ajv"));
const config_1 = require("./config");
const error_1 = require("./error");
const homepage = require("../package.json").homepage;
const remapEvents = {
    "tag:open": "tag:start",
    "tag:close": "tag:end",
};
const ajv = new ajv_1.default({ strict: true, strictTuples: true, strictTypes: true });
ajv.addMetaSchema(require("ajv/lib/refs/json-schema-draft-06.json"));
/**
 * Get (cached) schema validator for rule options.
 *
 * @param ruleId - Rule ID used as key for schema lookups.
 * @param properties - Uncompiled schema.
 */
function getSchemaValidator(ruleId, properties) {
    const $id = `rule/${ruleId}`;
    const cached = ajv.getSchema($id);
    if (cached) {
        return cached;
    }
    const schema = {
        $id,
        type: "object",
        additionalProperties: false,
        properties,
    };
    return ajv.compile(schema);
}
class Rule {
    constructor(options) {
        /* faux initialization, properly initialized by init(). This is to keep TS happy without adding null-checks everywhere */
        this.reporter = null;
        this.parser = null;
        this.meta = null;
        this.event = null;
        this.options = options;
        this.enabled = true;
        this.severity = 0;
        this.name = "";
    }
    getSeverity() {
        return this.severity;
    }
    setServerity(severity) {
        this.severity = severity;
    }
    setEnabled(enabled) {
        this.enabled = enabled;
    }
    /**
     * Returns `true` if rule is deprecated.
     *
     * Overridden by subclasses.
     */
    get deprecated() {
        return false;
    }
    /**
     * Test if rule is enabled.
     *
     * To be considered enabled the enabled flag must be true and the severity at
     * least warning.
     */
    isEnabled() {
        return this.enabled && this.severity >= config_1.Severity.WARN;
    }
    /**
     * Check if keyword is being ignored by the current rule configuration.
     *
     * This method requires the [[RuleOption]] type to include two properties:
     *
     * - include: string[] | null
     * - exclude: string[] | null
     *
     * This methods checks if the given keyword is included by "include" but not
     * excluded by "exclude". If any property is unset it is skipped by the
     * condition. Usually the user would use either one but not both but there is
     * no limitation to use both but the keyword must satisfy both conditions. If
     * either condition fails `true` is returned.
     *
     * For instance, given `{ include: ["foo"] }` the keyword `"foo"` would match
     * but not `"bar"`.
     *
     * Similarly, given `{ exclude: ["foo"] }` the keyword `"bar"` would match but
     * not `"foo"`.
     *
     * @param keyword - Keyword to match against `include` and `exclude` options.
     * @returns `true` if keyword is not present in `include` or is present in
     * `exclude`.
     */
    isKeywordIgnored(keyword) {
        const { include, exclude } = this.options;
        /* ignore keyword if not present in "include" */
        if (include && !include.includes(keyword)) {
            return true;
        }
        /* ignore keyword if present in "excludes" */
        if (exclude && exclude.includes(keyword)) {
            return true;
        }
        return false;
    }
    /**
     * Find all tags which has enabled given property.
     */
    getTagsWithProperty(propName) {
        return this.meta.getTagsWithProperty(propName);
    }
    /**
     * Find tag matching tagName or inheriting from it.
     */
    getTagsDerivedFrom(tagName) {
        return this.meta.getTagsDerivedFrom(tagName);
    }
    /**
     * JSON schema for rule options.
     *
     * Rules should override this to return an object with JSON schema to validate
     * rule options. If `null` or `undefined` is returned no validation is
     * performed.
     */
    static schema() {
        return null;
    }
    /**
     * Report a new error.
     *
     * Rule must be enabled both globally and on the specific node for this to
     * have any effect.
     */
    report(node, message, location, context) {
        if (this.isEnabled() && (!node || node.ruleEnabled(this.name))) {
            const where = this.findLocation({ node, location, event: this.event });
            this.reporter.add(this, message, this.severity, node, where, context);
        }
    }
    findLocation(src) {
        if (src.location) {
            return src.location;
        }
        if (src.event && src.event.location) {
            return src.event.location;
        }
        if (src.node && src.node.location) {
            return src.node.location;
        }
        return {};
    }
    on(event, ...args) {
        var _a;
        /* handle deprecated aliases */
        const remap = remapEvents[event];
        if (remap) {
            event = remap;
        }
        const callback = args.pop();
        const filter = (_a = args.pop()) !== null && _a !== void 0 ? _a : (() => true);
        return this.parser.on(event, (_event, data) => {
            if (this.isEnabled() && filter(data)) {
                this.event = data;
                callback(data);
            }
        });
    }
    /**
     * Called by [[Engine]] when initializing the rule.
     *
     * Do not override this, use the `setup` callback instead.
     *
     * @internal
     */
    init(parser, reporter, severity, meta) {
        this.parser = parser;
        this.reporter = reporter;
        this.severity = severity;
        this.meta = meta;
    }
    /**
     * Validate rule options against schema. Throws error if object does not validate.
     *
     * For rules without schema this function does nothing.
     *
     * @throws {@link SchemaValidationError}
     * Thrown when provided options does not validate against rule schema.
     *
     * @param cls - Rule class (constructor)
     * @param ruleId - Rule identifier
     * @param jsonPath - JSON path from which [[options]] can be found in [[config]]
     * @param options - User configured options to be validated
     * @param filename - Filename from which options originated
     * @param config - Configuration from which options originated
     *
     * @internal
     */
    static validateOptions(cls, ruleId, jsonPath, options, filename, config) {
        var _a;
        if (!cls) {
            return;
        }
        const schema = cls.schema();
        if (!schema) {
            return;
        }
        const isValid = getSchemaValidator(ruleId, schema);
        if (!isValid(options)) {
            /* istanbul ignore next: it is always set when validation fails */
            const errors = (_a = isValid.errors) !== null && _a !== void 0 ? _a : [];
            const mapped = errors.map((error) => {
                error.dataPath = `${jsonPath}${error.dataPath}`;
                return error;
            });
            throw new error_1.SchemaValidationError(filename, `Rule configuration error`, config, schema, mapped);
        }
    }
    /**
     * Rule documentation callback.
     *
     * Called when requesting additional documentation for a rule. Some rules
     * provide additional context to provide context-aware suggestions.
     *
     * @param context - Error context given by a reported error.
     * @returns Rule documentation and url with additional details or `null` if no
     * additional documentation is available.
     */
    /* eslint-disable-next-line @typescript-eslint/no-unused-vars */
    documentation(context) {
        return null;
    }
}
exports.Rule = Rule;
function ruleDocumentationUrl(filename) {
    const p = path_1.default.parse(filename);
    const rel = path_1.default.relative(path_1.default.join(__dirname, "rules"), path_1.default.join(p.dir, p.name));
    return `${homepage}/rules/${rel}.html`;
}
exports.ruleDocumentationUrl = ruleDocumentationUrl;
