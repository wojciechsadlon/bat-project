"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Engine = void 0;
const config_1 = require("../config");
const lexer_1 = require("../lexer");
const parser_1 = require("../parser");
const reporter_1 = require("../reporter");
const rule_1 = require("../rule");
const rules_1 = __importDefault(require("../rules"));
class Engine {
    constructor(config, configData, ParserClass) {
        this.report = new reporter_1.Reporter();
        this.configData = configData;
        this.config = config;
        this.ParserClass = ParserClass;
        /* initialize plugins and rules */
        const result = this.initPlugins(this.config);
        this.availableRules = Object.assign(Object.assign({}, rules_1.default), result.availableRules);
    }
    /**
     * Lint sources and return report
     *
     * @param src - Parsed source.
     * @returns Report output.
     */
    lint(sources) {
        for (const source of sources) {
            /* create parser for source */
            const parser = this.instantiateParser();
            /* setup plugins and rules */
            const { rules } = this.setupPlugins(source, this.config, parser);
            /* create a faux location at the start of the stream for the next events */
            const location = {
                filename: source.filename,
                line: 1,
                column: 1,
                offset: 0,
                size: 1,
            };
            /* trigger configuration ready event */
            const configEvent = {
                location,
                config: this.configData,
                rules,
            };
            parser.trigger("config:ready", configEvent);
            /* trigger source ready event */
            /* eslint-disable-next-line @typescript-eslint/no-unused-vars -- object destructured on purpose to remove property */
            const { hooks: _ } = source, sourceData = __rest(source, ["hooks"]);
            const sourceEvent = {
                location,
                source: sourceData,
            };
            parser.trigger("source:ready", sourceEvent);
            /* setup directive handling */
            parser.on("directive", (_, event) => {
                this.processDirective(event, parser, rules);
            });
            /* parse token stream */
            try {
                parser.parseHtml(source);
            }
            catch (e) {
                if (e instanceof lexer_1.InvalidTokenError || e instanceof parser_1.ParserError) {
                    this.reportError("parser-error", e.message, e.location);
                }
                else {
                    throw e;
                }
            }
        }
        /* generate results from report */
        return this.report.save(sources);
    }
    /**
     * Returns a list of all events generated while parsing the source.
     *
     * For verbosity, token events are ignored (use [[dumpTokens]] to inspect
     * token stream).
     */
    dumpEvents(source) {
        const parser = this.instantiateParser();
        const lines = [];
        parser.on("*", (event, data) => {
            /* ignore token events as it becomes to verbose */
            if (event === "token") {
                return;
            }
            lines.push({ event, data });
        });
        source.forEach((src) => parser.parseHtml(src));
        return lines;
    }
    dumpTokens(source) {
        const lexer = new lexer_1.Lexer();
        const lines = [];
        for (const src of source) {
            for (const token of lexer.tokenize(src)) {
                const data = token.data ? token.data[0] : null;
                lines.push({
                    token: lexer_1.TokenType[token.type],
                    data,
                    location: `${token.location.filename}:${token.location.line}:${token.location.column}`,
                });
            }
        }
        return lines;
    }
    dumpTree(source) {
        /* @todo handle dumping each tree */
        const parser = this.instantiateParser();
        const document = parser.parseHtml(source[0]);
        const lines = [];
        function decoration(node) {
            let output = "";
            if (node.hasAttribute("id")) {
                output += `#${node.id}`;
            }
            if (node.hasAttribute("class")) {
                output += `.${node.classList.join(".")}`;
            }
            return output;
        }
        function writeNode(node, level, sibling) {
            if (node.parent) {
                const indent = "  ".repeat(level - 1);
                const l = node.childElements.length > 0 ? "┬" : "─";
                const b = sibling < node.parent.childElements.length - 1 ? "├" : "└";
                lines.push(`${indent}${b}─${l} ${node.tagName}${decoration(node)}`);
            }
            else {
                lines.push("(root)");
            }
            node.childElements.forEach((child, index) => writeNode(child, level + 1, index));
        }
        writeNode(document, 0, 0);
        return lines;
    }
    /**
     * Get rule documentation.
     */
    getRuleDocumentation(ruleId, context // eslint-disable-line @typescript-eslint/explicit-module-boundary-types
    ) {
        const rules = this.config.getRules();
        if (rules.has(ruleId)) {
            const [, options] = rules.get(ruleId);
            const rule = this.instantiateRule(ruleId, options);
            return rule.documentation(context);
        }
        else {
            return null;
        }
    }
    /**
     * Create a new parser instance with the current configuration.
     *
     * @internal
     */
    instantiateParser() {
        return new this.ParserClass(this.config);
    }
    processDirective(event, parser, allRules) {
        const rules = event.data
            .split(",")
            .map((name) => name.trim())
            .map((name) => allRules[name])
            .filter((rule) => rule); /* filter out missing rules */
        switch (event.action) {
            case "enable":
                this.processEnableDirective(rules, parser);
                break;
            case "disable":
                this.processDisableDirective(rules, parser);
                break;
            case "disable-block":
                this.processDisableBlockDirective(rules, parser);
                break;
            case "disable-next":
                this.processDisableNextDirective(rules, parser);
                break;
            default:
                this.reportError("parser-error", `Unknown directive "${event.action}"`, event.location);
                break;
        }
    }
    processEnableDirective(rules, parser) {
        for (const rule of rules) {
            rule.setEnabled(true);
            if (rule.getSeverity() === config_1.Severity.DISABLED) {
                rule.setServerity(config_1.Severity.ERROR);
            }
        }
        /* enable rules on node */
        parser.on("tag:start", (event, data) => {
            data.target.enableRules(rules.map((rule) => rule.name));
        });
    }
    processDisableDirective(rules, parser) {
        for (const rule of rules) {
            rule.setEnabled(false);
        }
        /* disable rules on node */
        parser.on("tag:start", (event, data) => {
            data.target.disableRules(rules.map((rule) => rule.name));
        });
    }
    processDisableBlockDirective(rules, parser) {
        let directiveBlock = null;
        for (const rule of rules) {
            rule.setEnabled(false);
        }
        const unregisterOpen = parser.on("tag:start", (event, data) => {
            var _a, _b;
            /* wait for a tag to open and find the current block by using its parent */
            if (directiveBlock === null) {
                directiveBlock = (_b = (_a = data.target.parent) === null || _a === void 0 ? void 0 : _a.unique) !== null && _b !== void 0 ? _b : null;
            }
            /* disable rules directly on the node so it will be recorded for later,
             * more specifically when using the domtree to trigger errors */
            data.target.disableRules(rules.map((rule) => rule.name));
        });
        const unregisterClose = parser.on("tag:end", (event, data) => {
            /* if the directive is the last thing in a block no id would be set */
            const lastNode = directiveBlock === null;
            /* test if the block is being closed by checking the parent of the block
             * element is being closed */
            const parentClosed = directiveBlock === data.previous.unique;
            /* remove listeners and restore state */
            if (lastNode || parentClosed) {
                unregisterClose();
                unregisterOpen();
                for (const rule of rules) {
                    rule.setEnabled(true);
                }
            }
        });
    }
    processDisableNextDirective(rules, parser) {
        for (const rule of rules) {
            rule.setEnabled(false);
        }
        /* disable rules directly on the node so it will be recorded for later,
         * more specifically when using the domtree to trigger errors */
        const unregister = parser.on("tag:start", (event, data) => {
            data.target.disableRules(rules.map((rule) => rule.name));
        });
        /* disable directive after next event occurs */
        parser.once("tag:ready, tag:end, attr", () => {
            unregister();
            parser.defer(() => {
                for (const rule of rules) {
                    rule.setEnabled(true);
                }
            });
        });
    }
    /*
     * Initialize all plugins. This should only be done once for all sessions.
     */
    initPlugins(config) {
        for (const plugin of config.getPlugins()) {
            if (plugin.init) {
                plugin.init();
            }
        }
        return {
            availableRules: this.initRules(config),
        };
    }
    /**
     * Initializes all rules from plugins and returns an object with a mapping
     * between rule name and its constructor.
     */
    initRules(config) {
        const availableRules = {};
        for (const plugin of config.getPlugins()) {
            for (const [name, rule] of Object.entries(plugin.rules || {})) {
                if (!rule)
                    continue;
                availableRules[name] = rule;
            }
        }
        return availableRules;
    }
    /**
     * Setup all plugins for this session.
     */
    setupPlugins(source, config, parser) {
        const eventHandler = parser.getEventHandler();
        for (const plugin of config.getPlugins()) {
            if (plugin.setup) {
                plugin.setup(source, eventHandler);
            }
        }
        return {
            rules: this.setupRules(config, parser),
        };
    }
    /**
     * Load and setup all rules for current configuration.
     */
    setupRules(config, parser) {
        const rules = {};
        for (const [ruleId, [severity, options]] of config.getRules().entries()) {
            rules[ruleId] = this.loadRule(ruleId, config, severity, options, parser, this.report);
        }
        return rules;
    }
    /**
     * Load and setup a rule using current config.
     */
    loadRule(ruleId, config, severity, options, parser, report) {
        const meta = config.getMetaTable();
        const rule = this.instantiateRule(ruleId, options);
        rule.name = ruleId;
        rule.init(parser, report, severity, meta);
        /* call setup callback if present */
        if (rule.setup) {
            rule.setup();
        }
        return rule;
    }
    instantiateRule(name, options) {
        if (this.availableRules[name]) {
            const RuleConstructor = this.availableRules[name];
            return new RuleConstructor(options);
        }
        else {
            return this.missingRule(name);
        }
    }
    missingRule(name) {
        return new (class MissingRule extends rule_1.Rule {
            setup() {
                this.on("dom:load", () => {
                    this.report(null, `Definition for rule '${name}' was not found`);
                });
            }
        })();
    }
    reportError(ruleId, message, location) {
        this.report.addManual(location.filename, {
            ruleId,
            severity: config_1.Severity.ERROR,
            message,
            offset: location.offset,
            line: location.line,
            column: location.column,
            size: location.size || 0,
            selector: null,
        });
    }
}
exports.Engine = Engine;
