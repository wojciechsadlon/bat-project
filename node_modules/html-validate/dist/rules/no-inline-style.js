"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const rule_1 = require("../rule");
const defaults = {
    include: null,
    exclude: null,
    allowedProperties: ["display"],
};
function getCSSDeclarations(value) {
    return value
        .split(";")
        .filter(Boolean)
        .map((it) => {
        const [property, value] = it.split(":", 2);
        return { property: property.trim(), value: value.trim() };
    });
}
class NoInlineStyle extends rule_1.Rule {
    constructor(options) {
        super(Object.assign(Object.assign({}, defaults), options));
    }
    static schema() {
        return {
            exclude: {
                anyOf: [
                    {
                        items: {
                            type: "string",
                        },
                        type: "array",
                    },
                    {
                        type: "null",
                    },
                ],
            },
            include: {
                anyOf: [
                    {
                        items: {
                            type: "string",
                        },
                        type: "array",
                    },
                    {
                        type: "null",
                    },
                ],
            },
            allowedProperties: {
                items: {
                    type: "string",
                },
                type: "array",
            },
        };
    }
    documentation() {
        const text = [
            "Inline style is not allowed.\n",
            "Inline style is a sign of unstructured CSS. Use class or ID with a separate stylesheet.\n",
        ];
        if (this.options.allowedProperties.length > 0) {
            text.push("Under the current configuration the following CSS properties are allowed:\n");
            text.push(this.options.allowedProperties.map((it) => `- \`${it}\``).join("\n"));
        }
        return {
            description: text.join("\n"),
            url: rule_1.ruleDocumentationUrl(__filename),
        };
    }
    setup() {
        this.on("attr", (event) => this.isRelevant(event), (event) => {
            const { value } = event;
            if (this.allPropertiesAllowed(value)) {
                return;
            }
            this.report(event.target, "Inline style is not allowed");
        });
    }
    isRelevant(event) {
        if (event.key !== "style") {
            return false;
        }
        const { include, exclude } = this.options;
        const key = event.originalAttribute || event.key;
        /* ignore attributes not present in "include" */
        if (include && !include.includes(key)) {
            return false;
        }
        /* ignore attributes present in "exclude" */
        if (exclude && exclude.includes(key)) {
            return false;
        }
        return true;
    }
    allPropertiesAllowed(value) {
        if (typeof value !== "string") {
            return false;
        }
        const allowProperties = this.options.allowedProperties;
        /* quick path: no properties are allowed, no need to check each one individually */
        if (allowProperties.length === 0) {
            return false;
        }
        const declarations = getCSSDeclarations(value);
        return (declarations.length > 0 &&
            declarations.every((it) => {
                return allowProperties.includes(it.property);
            }));
    }
}
exports.default = NoInlineStyle;
