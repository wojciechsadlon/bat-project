"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EventHandler = void 0;
class EventHandler {
    constructor() {
        this.listeners = {};
    }
    /**
     * Add an event listener.
     *
     * @param event - Event names (comma separated) or '*' for any event.
     * @param callback - Called any time even triggers.
     * @returns Unregistration function.
     */
    on(event, callback) {
        const names = event.split(",").map((x) => x.trim());
        for (const name of names) {
            this.listeners[name] = this.listeners[name] || [];
            this.listeners[name].push(callback);
        }
        return () => {
            for (const name of names) {
                this.listeners[name] = this.listeners[name].filter((fn) => {
                    return fn !== callback;
                });
            }
        };
    }
    /**
     * Add a onetime event listener. The listener will automatically be removed
     * after being triggered once.
     *
     * @param event - Event names (comma separated) or '*' for any event.
     * @param callback - Called any time even triggers.
     * @returns Unregistration function.
     */
    once(event, callback) {
        const deregister = this.on(event, (event, data) => {
            callback(event, data);
            deregister();
        });
        return deregister;
    }
    /**
     * Trigger event causing all listeners to be called.
     *
     * @param event - Event name.
     * @param data - Event data.
     */
    /* eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types */
    trigger(event, data) {
        var _a, _b;
        const callbacks = [...((_a = this.listeners[event]) !== null && _a !== void 0 ? _a : []), ...((_b = this.listeners["*"]) !== null && _b !== void 0 ? _b : [])];
        callbacks.forEach((listener) => {
            listener.call(null, event, data);
        });
    }
}
exports.EventHandler = EventHandler;
exports.default = EventHandler;
